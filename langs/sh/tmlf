#!/bin/sh
USAGE='tmlf — minimal tag-based ANSI formatter

USAGE
  tmlf "format" [args...]
  tmlf -h

DESCRIPTION
  Expands printf-style format strings, then converts XML-like tags
  into ANSI escape sequences. Stack-based, respects NO_COLOR.

TAGS
  Attributes:  <bold> <italic> <ul> <strike> <inv> <dim> <blink> <hidden>
  Colors:      <black> <red> <green> <yellow> <blue> <magenta> <cyan> <white> <default>
  Modifiers:   <bright-COLOR> <bg-COLOR> <bright-bg-COLOR>
  Special:     <br> <lt> <gt>

  Tags are only interpreted if properly opened AND closed.

ENVIRONMENT
  NO_COLOR  Disables all ANSI formatting
'

# --- TEST
[ -n "$_TEST_TMLF" ] && {
	unset _TEST_TMLF
	$0 "plain text\n"
	$0 "<bold>bold</bold>\n"
	$0 "<red>red</red>\n"
	$0 "<green>green <bold>bold</bold></green>\n"
	$0 "<blue><ul>blue underlined</ul></blue>\n"
	$0 "<bright-red>bright red</bright-red>\n"
	$0 "<bg-yellow>bg yellow</bg-yellow>\n"
	$0 "<bright-bg-blue>bright bg blue</bright-bg-blue>\n"
	$0 "<red>nested <green>green</green> back</red>\n"
	$0 "mix <bold><red>bold red</red></bold> end\n"
	$0 "lt=<lt><br>gt=<gt>\n"
	$0 "line1<br>line2\n"
	$0 "<italic>italic <strike>strike</strike></italic>\n"
	$0 "<cyan>cyan <inv>inv</inv></cyan>\n"
	$0 "<default>default</default>\n"
	$0 "no tags just text\n"
	exit 0
}

# --- USAGE
[ "$#" -eq 0 ] && { printf '%s\n' "$USAGE";	exit 0; }

# --- PRE-PROCESS (sentinel)
fmt=$1
shift
input=$(printf "$fmt" "$@"; printf 'X')
input=${input%X}

# --- SETUP
ESC=$(printf '\033')
stack=""

if [ -n "${NO_COLOR+x}" ]; then
	emit()   { :; }
	reset()  { :; }
	replay() { :; }
else
	emit()   { printf '%s[%sm' "$ESC" "$1"; }
	reset()  { printf '%s[0m'  "$ESC"; }
	replay() {
		reset
		for e in $stack; do
			emit "${e#*:}"
		done
	}
fi

# --- PARSE LOOP
while [ -n "$input" ]; do
	text=${input%%<*}
	rest=${input#*<}

	printf '%s' "$text"
	[ "$text" = "$input" ] && break

	tag=${rest%%>*}
	input=${rest#*>}

	# literal '<' without closing '>'
	[ "$tag" = "$rest" ] && {
		printf '<%s' "$rest"
		break
	}

	case "$tag" in
		br) printf '\n' ;;
		lt) printf '<'  ;;
		gt) printf '>'  ;;

		/*)
			# close = pop one level
			stack=${stack% *}
			replay
			;;

		*)
			mod=0
			core=$tag

			case "$core" in
				bright-bg-*) mod=70; core=${core#bright-bg-} ;;
				bright-*)    mod=60; core=${core#bright-}    ;;
				bg-*)        mod=10; core=${core#bg-}        ;;
			esac

			base=""
			case "$core" in
				bold)    base=1  ;; dim)     base=2  ;;
				italic)  base=3  ;; ul)      base=4  ;;
				blink)   base=5  ;; inv)     base=7  ;;
				hidden)  base=8  ;; strike)  base=9  ;;
				black)   base=30 ;; red)     base=31 ;;
				green)   base=32 ;; yellow)  base=33 ;;
				blue)    base=34 ;; magenta) base=35 ;;
				cyan)    base=36 ;; white)   base=37 ;;
				default) base=39 ;;
			esac

			# invalid tag → literal
			[ -n "$base" ] || {
				printf '<%s>' "$tag"
				continue
			}

			# must have matching closing tag
			case "$input" in
				*"</$tag>"*) ;;
				*)
					printf '<%s>' "$tag"
					continue
					;;
			esac

			code=$((base + mod))
			emit "$code"
			stack="$stack $tag:$code"
			;;
	esac
done

reset
